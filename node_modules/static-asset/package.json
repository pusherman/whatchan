{
  "author": {
    "name": "Blake Miner",
    "email": "miner.blake@gmail.com",
    "url": "http://www.blakeminer.com"
  },
  "name": "static-asset",
  "description": "Static asset manager for Node.JS and Express",
  "keywords": [
    "asset",
    "static",
    "cache",
    "caching",
    "fingerprint",
    "express",
    "middleware"
  ],
  "version": "0.5.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/bminer/node-static-asset.git"
  },
  "main": "index.js",
  "engines": {
    "node": ">=0.8"
  },
  "dependencies": {
    "crc": ">=0.2"
  },
  "devDependencies": {},
  "readme": "#node-static-asset\n\nnode-static-asset is a static asset manager for Node.JS, designed for Express.\nThis project aims to solve the problem of caching static assets (including\nassets like *.js files that might change from time to time).\n\n## Background\n\nGoogle has a nice article about \"strong\" and \"weak\" caching.  It's worth a quick\nread if you don't know what that means.\n\nhttps://developers.google.com/speed/docs/best-practices/caching\n\n## Install\n\n`npm install static-asset`\n\n## Getting Started\n\nnode-static-asset allows you to generate URL fingerprints for static assets.\n\n1. Add the static-asset middleware to your Express stack\n```javascript\nvar staticAsset = require('static-asset');\napp.use(staticAsset(__dirname + \"/public/\") );\n```\n\n2. Get URL fingerprints of your static resources using `req.assetFingerprint`\nor the `assetFingerprint` view helper function.\n```javascript\napp.get(\"/info\", function(req, res, next) {\n\t/* Should return something like \"The URL fingerprint for jQuery is:\n\t\t/js/jquery.min.js?v=3dd-983jk2a\"\n\t*/\n\tres.type(\"text/plain\").send(\"The URL fingerprint for jQuery is: \" +\n\t\treq.assetFingerprint(\"/js/jquery.min.js\") );\n});\n```\n\nNow that you have obtained the asset fingerprint for `/js/jquery.min.js`,\nif you send a request for that asset to the URL `/js/jquery.min.js?v=3dd-983jk2a`,\nstatic-asset will automatically add appropriate caching headers (i.e.\nLast-Modified, ETag, and Expires).\n\n## API\n\nstatic-asset exposes a function `req.assetFingerprint`, which allows one to generate\nand register URL fingerprints for static assets.\n\nOnce a URL fingerprint is *registered* with static-asset, any HTTP request for that\nstatic asset (i.e. when `req.url` matches the registered URL fingerprint) will\ntrigger static-asset to set certain HTTP headers (i.e. Last-Modified, ETag, or\nExpires).\n\n### Adding the middleware function\n\n**require('static-asset')(path[, cache])** - Returns an Express middleware\nfunction that exposes a `req.assetFingerprint` function and adds\n`assetFingerprint` view helper function to `res.locals`.  If any request's URL\nmatches a previously generated URL fingerprint, static-asset will attempt to add\nweak and strong caching headers to the HTTP response.\n\n- `path` - the path from which static files are served\n- `cache` - a \"cache strategy\" Object, which must implement all \"cache\n\tstrategy\" methods, as described below. If `cache` is omitted, the\n\tdefault \"cache stategy\" is used.\n\n### A \"Cache Strategy\" Object\n\nA \"cache strategy\" object should implement one or more of the following methods:\n\n- `lastModified(filename)` - a function that accepts a filename and returns\n\tits last modified date. If a last modified date could not\n\tbe determined, the function should return `null`; otherwise, static-asset\n\t*may* use this Date to set the `Last-Modified` HTTP response header when\n\tthe resource is requested.\n- `etag(filename, cb)` - Same as lastModified (above), except that it must\n\treturn an ETag (or hash value).  If the\n\treturned ETag is not `null`, static-asset *may* use this value to set the\n\t`ETag` HTTP header when the named resource is requested.\n- `expires(filename)` - Same as lastModified (above), except\n\tthat it must return a Date Object indicating when the resource shall\n\texpire. The Date may be no more than one year in the future. If\n\t`expires` is implemented, static-asset *may* use the date to set an\n\t`Expires` and/or `Cache-Control: max-age` HTTP headers; otherwise,\n\tstatic-asset will use a Date approximately one year into the future.\n- `fileFingerprint(filename, fullPath)` - Returns the URL fingerprint\n\tof the resource `filename`, stored at the location `fullPath`.\n\t`fullPath` is provided for convenience, since the caching strategy\n\tdoes not know what root path was passed into the static-asset middleware.\n\n### Registering URL fingerprints\n\n**req.assetFingerprint(label_or_filename)** - Return a URL fingerprint for the\nlabelled resource, or if no such label is registered, use the \"cache\nstrategy\" to determine the file's ETag or last modified date.  If you're confused\nby this description, read on...\n\nIf you call `req.assetFingerprint(filename)` and pass a filename relative to the\npath from which static files are served, static-asset will use the cache strategy\nyou specified to generate and return a unique URL fingerprint for the asset.\nIf that file is requested later by the URL fingerprint, static-asset will respond\nby setting the appropriate HTTP headers like Last-Modified, ETag, and Expires,\naccording to the cache strategy.\n\nIf an ETag is provided by the cache strategy, it will be used to generate the\nfingerprint; otherwise, the last modified date will be used.\n\nIf you call `req.assetFingerprint()` with no arguments, a fingerprint will be\nregistered and generated using the cache strategy on the current URL (i.e.\n`req.url`). This is equivalent to `req.assetFingerprint(req.url)`.\n\n### Labelled resources\n\nYou can call `req.assetFingerprint(label, fingerprint, cacheInfo)` to manually\nassign a `fingerprint` for the specified `label`. In addition, the HTTP headers\nreturned to the client when this URL fingerprint is requested are specified by\nthe `cacheInfo` Object.\n\n**req.assetFingerprint(label, urlFingerprint, cacheInfo)** - Registers a URL\nfingerprint for a labelled resource.\n\n- `label` - a label identifying the resource\n- `urlFingerprint` - the URL fingerprint for the resource. If a request for this\n\tresource is made, static-asset may add caching headers to the response.\n- `cacheInfo` - an Object containing one or more of these properties:\n\t- `lastModified` - the last modified date of the resource\n\t- `etag` - the ETag of the resource\n\t- `expires` - the expiration date of the resource\n\nOther middleware on the stack can generate their own URL fingerprints for\nstatic resources and expose them through `req.assetFingerprint`. Like this:\n\n```javascript\n//Suppose we are in a middleware function, designed to uglify JS files...\n//stat will refer to the stat Object generated by `fs.stat`\nreq.assetFingerprint(javascript_filename, javascript_filename + \"?v=\" +\n\tstat.mdate.getTime(), {\"lastModified\": stat.mdate});\n```\n\nIf you call `req.assetFingerprint(label)` and pass a label, static-asset will return\nthe fingerprint for the resource, as specified by the last corresponding\n`req.assetFingerprint(label, fingerprint, cacheInfo)` call.  If that file is requested,\nstatic-asset will respond by setting the appropriate HTTP headers, according to the\n`cacheInfo` Object passed to the last\n`req.assetFingerprint(label, fingerprint, cacheInfo)` call.\n\n\n### Default Caching Strategy\n\nstatic-asset can be fully customized, but it has some basic, reasonably sane default behavior.\nBy default, static-asset does the following:\n\n- The URL fingerprint of the resource is based on the ETag\n- The ETag is generated based upon the file size and the file's CRC-32 hash.\n- The last modified date is pulled from `fs.stat`\n- The expires date is set to one year in the future\n- The default strategy relies on [`connect.static`]\n(http://www.senchalabs.org/connect/middleware-static.html) to load the resource from\nthe filesystem.\n- In development environments (based on `process.env.NODE_ENV`), the URL fingerprint\nwill be updated whenever the file changes\n- In production environments, the URL fingerprints are cached and cannot\nchange until the server is restarted.\n\n## Basic Usage\n\nUsually, this should be good enough to get started.\n\n```javascript\nvar express = require('express');\nvar app = express();\nvar staticAsset = require('static-asset');\napp.use(staticAsset(__dirname + \"/public/\") );\napp.use(express.static(__dirname + \"/public/\") );\n//... application code follows (routes, etc.)\n```\n\nFor example, if you want to include your client-side JavaScript code, simply\ndo this in your [Jade](https://github.com/visionmedia/jade) or [Blade]\n(https://github.com/bminer/node-blade) view:\n\n```jade\nscript(type=\"text/javascript\", src=assetFingerprint(\"/client.js\") )\n```\n\nThis will render to something like this:\n\n```html\n<script type=\"text/javascript\" src=\"/client.js?v=1318365481\"></script>\n```\n\nNotice that static-asset added a URL fingerprint (the UNIX timestamp\n1318365481) to the filename.\n\n## More Advanced Usage\n\nYou can override the \"cache strategy\" with your own implementation that might\nallow you to:\n\n- Upload the asset to Amazon S3 and generate a URL fingerprint that points to S3\n- Fly in a spaceship to the moon\n- Do something really crazy like generate URL fingerprints that are\nBase64-encoded MD5-hashes of the names of random lunar craters.\n",
  "readmeFilename": "README.md",
  "_id": "static-asset@0.5.0",
  "dist": {
    "shasum": "ea487f40b3e7354c9aa330b603568f510eacadbc"
  },
  "_from": "static-asset"
}
